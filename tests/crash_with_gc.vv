// This file serves as a MRE (minimal reproducible example) of a runtime crash triggered by compiling and running
// this file with `v -d sdl_use_gc run ~/.vmodules/sdl/tests/crash_with_gc.vv`. On some setups, the problem seems to be
// memory corruption happening between actions in SDL3's memory allocations and V's default garbage collector.
// Especially when a lot of heap allocations occur.
//
// The example crashes if compiled and run with `-d sdl_use_gc`.
// See also: https://github.com/vlang/sdl/issues/744
module main

import sdl

struct Data1 {
mut:
	a int
}

struct SDLApp {
	window   &sdl.Window   = unsafe { nil }
	renderer &sdl.Renderer = unsafe { nil }
}

fn main() {
	mut app := SDLApp{}

	mut data1 := []&Data1{cap: 200}
	for i in 0 .. 200 {
		data1 << &Data1{
			a: i
		}
	}

	sdl.init(sdl.init_video | sdl.init_events)

	if !sdl.create_window_and_renderer('Hello SDL3'.str, 500, 300, sdl.WindowFlags(0),
		&app.window, &app.renderer) {
		error_msg := unsafe { cstring_to_vstring(sdl.get_error()) }
		panic('Could not create SDL window and renderer. SDL error:\n${error_msg}')
	}

	mut should_close := false
	mut ticks := 0
	for {
		ticks++
		evt := sdl.Event{}
		for sdl.poll_event(&evt) {
			match evt.type {
				.quit {
					should_close = true
				}
				.key_down {
					key := unsafe { sdl.KeyCode(evt.key.key) }
					match key {
						.escape { should_close = true }
						else {}
					}
				}
				else {}
			}
		}

		data1[0].a = ticks
		data1.delete(10)
		data1 << &Data1{
			a: ticks
		}

		println('ticks: ${ticks}')
		if should_close || ticks == 1000 {
			break
		}

		sdl.set_render_draw_color(app.renderer, 255, 55, 55, sdl.alpha_opaque)
		sdl.render_clear(app.renderer)
		sdl.render_present(app.renderer)
	}
	println('Exiting. If this was compiled with `-d sdl_use_gc`, an invalid memory access error should occur')

	sdl.destroy_renderer(app.renderer)
	sdl.destroy_window(app.window)
	sdl.quit()
}
